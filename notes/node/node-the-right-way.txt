Part One
Chapter 1

Thinking Beyond the Web:

    -I/O-bound programs   :
        - are constrained by data access. 
        - e.g.. AJAX, REST, HTTP, web
        -These are programs where adding more processing power or RAM often makes little difference

    -Client-Side Programs  :
        - interact directly with human beings
        - e.g.. GUI tools of all stripes, consumer applications, mobile apps, and web apps

    -Server-side programs  :      
        - HTTP, Ajax,and REST, communicating with JSON
        - websites, apps, and APIs live here

How Node.js Applications Work:

    - couples JavaScript with an event loop for quickly dispatching opera-tions when events occur

    - Event loop :
        1. load the programs
        2. while theres more to do, wait for something to happen
        3. execute callbacks
        4. exit process unless theres more to do
        - core feature of Node
        - “everything runs in parallel except your code.”
        - As long as there’s something left to do, Node.js’s event loop will keep spinning.
        - Whenever an event occurs, Node.js invokes any callbacks (event handlers) that are listening for that event

    Single-Threaded and Highly Parallel
        -Node.js is a single-threaded environment (only one line of your code will ever be executing at any time)
        -Rather than waiting line-by-line for an operation to finish, youcreate a callback function that will be invoked when the operation eventuallysucceeds or fails.


Aspects of Node.js Development:

    -Practical Programming:
        - producing real code that does something useful

    -Node.js Core: 
        - How information is shuttled between these layersis the kind of impactful architectural detail you’ll learn.
    
    -JavaScriptisms:
        - arrowfunctions, spread parameters, and destructuring assignment

Installing Node.js:

    - $node--version
        see what version you have installed
    
    -you can install nvm like so:
        - $curl https://raw.github.com/creationix/nvm/master/install.sh | sh

    - Then install a specific version:
        - $nvm install v8.0.0gs
        

_______________________________________________________________________________________________________________________

Part one
Chapter 2
    
    Arrow Function Expression ()=> {} : 
        - have a terser syntax than older function expression 
        - they do not create a new scope for 'this'

    Visualizing the Event Loop
        The event loop spinds until there is nothing to do

    Template Strings : ${ filename }

    Spawning a Child process:
            “use strict'​;
        ​ 	​const​ fs = require(​'fs'​);
        ​ 	​const​ spawn = require(​'child_process'​).spawn;
        ​ 	​const​ filename = process.argv[2];
        ​ 	
        ​ 	​if​ (!filename) {
        ​ 	  ​throw​ Error(​'A file to watch must be specified!'​);
        ​ 	}
        ​ 	
        ​ 	fs.watch(filename, () => {
        ​ 	  ​const​ ls = spawn(​'ls'​, [​'-l'​, ​'-h'​, filename]);
        ​ 	  ls.stdout.pipe(process.stdout);
        ​ 	});
        ​ 	console.log(​`​​Now watching ​​${​filename​}​​ for changes...`​);

        Save the file as watcher-spawn.js and run it with node as before:

        ​ 	​$ ​​node​​ ​​watcher-spawn.js​​ ​​target.txt​
        ​ 	Now watching target.txt for changes...

        If you go to a different console and touch the target file, your Node.js program will produce something like this:

        ​ 	-rw-rw-r-- 1 jimbo jimbo 6 Dec  8 05:19 target.txt”
    

    Capturing Data from an EventEmitter:
        EventEmitter is a very important class in Node. 
            a channel for events to be dispatched and listerners to be notified.
            many objects in NOde inherit from Event EMitter, like Streams*

            “filesystem/watcher-spawn-parse.js
            ​ 	fs.watch(filename, () => {
            ​ 	  ​const​ ls = spawn(​'ls'​, [​'-l'​, ​'-h'​, filename]);
            ​ 	  ​let​ output = ​''​;
            ​ 	
            ​ 	  ls.stdout.on(​'data'​, chunk => output += chunk);
            ​ 	
            ​ 	  ls.on(​'close'​, () => {
            ​ 	    ​const​ parts = output.split(​/​​\s​​+/​);
            ​ 	    console.log([parts[0], parts[4], parts[8]]);
            ​ 	  });
            ​ 	});”

          run it..   
            “$ ​​node​​ ​​watcher-spawn-parse.js​​ ​​target.txt​
        ​ 	Now watching target.txt for changes...
        ​ 	[ '-rw-rw-r--', '0', 'target.txt' ]”

    Event listerners
        a callback function that is invoked when an 
        event of a specified type is dispatched.

        Since the Stream class inherits from EventEmitter, 
        we can listen for events from the child process’s standard output stream:

            ls.stdout.on(​'data'​, chunk => output += chunk);”

        When an arrow function takes a exactky one parameter, 
        you can omit the parenthesis arounf the param.

        .on() 
            adds a listener for the specified event type
        
        We listen fir data events because we're interested in 
        data coming out of the stream

        Events can send laong extra information which arrives in 
        the formof parameters to the callbacks
        
        data events pass along a Buffer objects 
            each time we het a chunk of data, we append it to our output

    Buffer 
        Node's way of representing binary data
        It points to a blob of memory allocated by Node's 
            native core
        Buffers cant be resized and require encoding and 
            decoding to convert to and from JS Strings
        

        Like Stream, the ChildProcess class extends EventEmitter, 
        so we can add listeners to it, as well.

        ​ 	ls.on(​'close'​, () => {
        ​ 	  ​const​ parts = output.split(​/​​\s​​+/​);
        ​ 	  console.log([parts[0], parts[4], parts[8]]);
        ​ 	});
    
Reading and Writing Files Asynchronously:

        “use strict'​;
        ​ 	​const​ fs = require(​'fs'​);
        ​ 	fs.readFile(​'target.txt'​, (err, data) => {
        ​ 	  ​if​ (err) {
        ​ 	    ​throw​ err;
        ​ 	  }
        ​ 	  console.log(data.toString());
        ​ 	});
        Save this file as read-simple.js and run it with node:

        ​ 	​$ ​​node​​ ​​read-simple.js​”


    


_______________________________________________________________________________________________________________________
Look into...

streams